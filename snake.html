<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polished Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;
        let highscore = 0;
        let isAuthReady = false;
        
        // Function to initialize Firebase and authentication
        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                            } else {
                                const anonymousUser = await signInAnonymously(auth);
                                userId = anonymousUser.user.uid;
                            }
                        } catch (error) {
                            console.error("Firebase auth failed:", error);
                        }
                    }
                    isAuthReady = true;
                    if (userId) {
                        setupHighscoreListener();
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        }
        
        // Set up real-time listener for high score
        function setupHighscoreListener() {
            if (!db || !userId) return;
            const highscoreDocRef = doc(db, 'artifacts', appId, 'users', userId, 'highscores', 'snake');
            onSnapshot(highscoreDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    highscore = docSnap.data().value || 0;
                    document.getElementById('highscore').textContent = highscore;
                }
            });
        }
        
        // Save the high score to Firestore
        async function saveHighscore(score) {
            if (!db || !userId) {
                console.error("Firestore not initialized or user not authenticated.");
                return;
            }
            if (score > highscore) {
                const highscoreDocRef = doc(db, 'artifacts', appId, 'users', userId, 'highscores', 'snake');
                try {
                    await setDoc(highscoreDocRef, { value: score }, { merge: true });
                } catch (e) {
                    console.error("Error saving high score: ", e);
                }
            }
        }

        // --- Game Logic ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const messageBox = document.getElementById('messageBox');
        const scoreElement = document.getElementById('score');
        
        const gridSize = 20;
        let snake, food, direction, score, gameLoopInterval, lastUpdateTime, gameSpeed;
        let touchStartX, touchStartY;
        let gameActive = false;
        
        // Improved sound effects
        const eatSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'sine' },
            envelope: {
                attack: 0.005,
                decay: 0.1,
                sustain: 0,
                release: 0.05
            }
        }).toDestination();
        
        const gameOverSynth = new Tone.MonoSynth({
            oscillator: { type: 'square' },
            envelope: {
                attack: 0.05,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5
            },
            filterEnvelope: {
                attack: 0.06,
                decay: 0.2,
                sustain: 0.5,
                release: 0.5,
                baseFrequency: 200,
                octaves: 2
            }
        }).toDestination();
        
        function playEatSound() {
            eatSynth.triggerAttackRelease(['C5', 'E5', 'G5'], '8n');
        }
        
        function playGameOverSound() {
            gameOverSynth.triggerAttackRelease('C3', '4n');
            gameOverSynth.triggerAttackRelease('B2', '4n', '+0.1');
            gameOverSynth.triggerAttackRelease('F2', '4n', '+0.2');
        }

        function resizeCanvas() {
            // Set canvas size dynamically for a larger playing area
            const size = Math.min(gameContainer.clientWidth, window.innerHeight * 0.7);
            canvas.width = size - (size % gridSize); // Ensure canvas size is a multiple of grid size
            canvas.height = size - (size % gridSize);
        }

        function resetGame() {
            gameActive = false;
            snake = [{ x: Math.floor(canvas.width / gridSize / 2), y: Math.floor(canvas.height / gridSize / 2) }];
            direction = 'right';
            score = 0;
            gameSpeed = 150;
            scoreElement.textContent = score;
            generateFood();
            draw();
            messageBox.style.display = 'flex';
            messageBox.innerHTML = `
                <h2 class="text-3xl sm:text-4xl font-bold mb-4 text-gray-800">Snake Game</h2>
                <p class="text-lg sm:text-xl text-center mb-6 text-gray-600">Use WASD or arrow keys, or swipe on the screen to play.</p>
                <button id="startButton" class="px-6 py-3 bg-green-500 hover:bg-green-600 text-white font-bold rounded-full shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105 active:scale-95">Tap to Play</button>
            `;
            document.getElementById('startButton').addEventListener('click', startGame);
        }

        function startGame() {
            if (!gameActive) {
                // Tone.js requires a user interaction to start audio context
                Tone.start();
                gameActive = true;
                messageBox.style.display = 'none';
                lastUpdateTime = performance.now();
                gameLoopInterval = setInterval(gameLoop, gameSpeed);
            }
        }

        function gameLoop() {
            const currentTime = performance.now();
            if (currentTime - lastUpdateTime > gameSpeed) {
                update();
                draw();
                lastUpdateTime = currentTime;
            }
        }

        function update() {
            if (!gameActive) return;

            const head = { x: snake[0].x, y: snake[0].y };

            switch (direction) {
                case 'up': head.y -= 1; break;
                case 'down': head.y += 1; break;
                case 'left': head.x -= 1; break;
                case 'right': head.x += 1; break;
            }

            // Check for game over
            const cols = canvas.width / gridSize;
            const rows = canvas.height / gridSize;
            if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows || checkCollision(head)) {
                endGame();
                return;
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score += 1;
                scoreElement.textContent = score;
                playEatSound();
                generateFood();
                // Speed up the game
                gameSpeed = Math.max(50, gameSpeed - 2);
                clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, gameSpeed);
            } else {
                snake.pop();
            }
        }

        function checkCollision(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function generateFood() {
            food = {
                x: Math.floor(Math.random() * (canvas.width / gridSize)),
                y: Math.floor(Math.random() * (canvas.height / gridSize))
            };
        }

        function draw() {
            // Background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Food - pulsing effect
            const pulse = 1 + Math.sin(performance.now() * 0.005) * 0.1;
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 * pulse, 0, Math.PI * 2);
            ctx.fill();

            // Snake
            snake.forEach((segment, index) => {
                // Head
                if (index === 0) {
                    const gradient = ctx.createLinearGradient(
                        segment.x * gridSize, segment.y * gridSize,
                        segment.x * gridSize + gridSize, segment.y * gridSize + gridSize
                    );
                    gradient.addColorStop(0, '#10b981');
                    gradient.addColorStop(1, '#059669');
                    ctx.fillStyle = gradient;
                    // Eyes
                    const eyeRadius = gridSize / 8;
                    ctx.fillStyle = '#1f2937';
                    const pupilRadius = gridSize / 16;
                    ctx.fillStyle = '#1f2937';
                    ctx.beginPath();
                    ctx.arc(segment.x * gridSize + gridSize * 0.3, segment.y * gridSize + gridSize * 0.3, eyeRadius, 0, Math.PI * 2);
                    ctx.arc(segment.x * gridSize + gridSize * 0.7, segment.y * gridSize + gridSize * 0.3, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();

                } else {
                    ctx.fillStyle = '#34d399';
                }
                ctx.beginPath();
                ctx.roundRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize, [5]);
                ctx.fill();
                ctx.strokeStyle = '#e5e7eb';
                ctx.stroke();
            });
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameLoopInterval);
            playGameOverSound();
            saveHighscore(score);
            messageBox.style.display = 'flex';
            messageBox.innerHTML = `
                <h2 class="text-3xl sm:text-4xl font-bold mb-2 text-red-500">Game Over!</h2>
                <p class="text-lg sm:text-xl text-center mb-4 text-gray-600">Your Score: ${score}</p>
                <button id="restartButton" class="px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-full shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105 active:scale-95">Play Again</button>
            `;
            document.getElementById('restartButton').addEventListener('click', resetGame);
        }

        // Event Listeners
        window.addEventListener('resize', () => {
          resizeCanvas();
          draw();
        });

        document.addEventListener('keydown', e => {
            if (!gameActive) return;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction !== 'down') direction = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction !== 'up') direction = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction !== 'right') direction = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction !== 'left') direction = 'right';
                    break;
            }
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (e.changedTouches.length === 0) return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && direction !== 'left') direction = 'right';
                else if (dx < 0 && direction !== 'right') direction = 'left';
            } else {
                if (dy > 0 && direction !== 'up') direction = 'down';
                else if (dy < 0 && direction !== 'down') direction = 'up';
            }
        });

        window.onload = function() {
            initializeFirebase();
            resizeCanvas();
            resetGame();
        };

    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #f0f4f8; /* Light background */
        }
        #gameCanvas {
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            width: 100%;
            height: auto;
            border: 1px solid #e2e8f0;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 2px solid #cbd5e0;
            border-radius: 15px;
            padding: 24px;
            text-align: center;
            color: #1a202c;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div id="gameContainer" class="flex flex-col items-center p-6 bg-white rounded-2xl shadow-2xl w-full max-w-2xl">
        <h1 class="text-4xl font-extrabold mb-2 text-green-600">Snake</h1>
        <div class="w-full flex justify-between items-center mb-6">
            <div class="flex flex-col items-center">
                <span class="text-sm font-semibold text-gray-500">Score</span>
                <span id="score" class="text-3xl font-bold text-yellow-600">0</span>
            </div>
            <div class="flex flex-col items-center">
                <span class="text-sm font-semibold text-gray-500">High Score</span>
                <span id="highscore" class="text-3xl font-bold text-indigo-600">0</span>
            </div>
        </div>
        <canvas id="gameCanvas" class="w-full h-auto rounded-xl"></canvas>

        <div id="messageBox" class="absolute hidden"></div>
    </div>

</body>
</html>

